# 数据结构课程设计开题报告

> 课程名称：数据结构课程设计  
> 文档版本：v1.0  
> 提交日期：2025年12月30日

## 一、基本信息

- **项目名称**：支持姓名或电话前缀检索的通讯录管理系统
- **小组人员**：徐书泽，顾雨辰
- **关键词**：双向链表、Trie 树、散列表（哈希表）、前缀检索、原子持久化、命令行交互、数据一致性、索引加速

## 二、项目概述

### 2.1 项目背景

- 在数字化办公、日常社交和个人信息管理场景中，通讯录是高频使用的基础工具，但不同场景下的通讯录管理存在显著痛点：
  
  - 传统管理方式低效：纸质通讯录易丢失、修改麻烦；简单的文本 / 表格存储通讯录，检索时需全量翻找，数据量稍大时效率极低；
  - 数据一致性难保障：手动维护的通讯录易出现重复联系人、数据丢失等问题；
  - 轻量化需求未被满足：专业通讯录软件虽功能完善，但多依赖图形界面、云端存储，对于仅需本地管理、快速检索的场景，存在功能冗余、操作复杂的问题；
  - 检索效率瓶颈：常规通讯录仅支持精确匹配，无法满足前缀模糊检索的高频需求。
- 本项目针对 “本地、轻量化、高效检索” 的核心需求，平衡了功能与性能：既解决了传统通讯录检索慢、数据易丢失的痛点，又避免了大型通讯录软件的冗余设计，可作为个人本地通讯录管理的轻量化解决方案，也为数据结构落地应用提供了典型案例。
  
  ### 2.2 项目要求
  
  本题要求实现一个支持姓名或电话前缀检索的通讯录管理系统，
  强调顺序存储与索引加速的组合设计。联系人信息建议至少包含：姓名、电话、可选备注字段。
  
- 系统需以双向链表维护联系人主表（支持插入、删除、遍历），并在内存中构建散列表或者Trie树作为索引以加速检索，索引的键可以选择姓名前缀或电话前缀。
  
- 输入约定建议：
  采用命令驱动交互，至少支持 ADD name phone、DEL key、FIND_NAME prefix
  与/或 FIND_PHONE prefix、LIST。关于重名/重复号码的处理规则需固定（如允许重复、或以手
  机号为唯一键覆盖更新），并体现在输出与报告中。
  
- 输出约定建议：
  对查询命令输出匹配联系人列表（允许限定输出条数并提供截断提示）；对插
  入/删除输出执行结果（成功/失败原因）。在程序结束或显式 SAVE 时输出持久化摘要（写入记录
  数、文件名等）。
  
- 持久化要求：
  插入、删除后的变更需写入文件，并说明如何保证原子性（例如写临时文件后重命
  名、或采用简化 WAL 日志回放机制）。不要求实现复杂事务，但需保证异常中断后重启不会导
  致文件格式损坏，并能恢复到某个一致状态。
  
- 测试要求：
  至少提供五组检索用例，对比线性扫描（仅链表）与索引查询的平均检索时延；测试
  规模可自行设定，但需在报告中给出规模与计时方法。
  
  ### 2.3 要解决的问题
  
  #### 一、核心功能层面需解决的问题
  
- 联系人基础管理问题
  需满足用户对联系人的管理功能需求，解决简单文本存储带来的操作低效、易出错问题：
  添加问题：支持联系人姓名、电话、备注的快速添加，且保证手机号唯一性以避免重复存储，重复手机号添加时覆盖旧数据，解决重复联系人问题；
  删除问题：支持按手机号删除联系人；
  遍历问题：支持全量联系人列表展示，解决文本存储需逐行查找问题。
  
- 高效检索问题
  解决全量遍历检索效率低、体验差的核心痛点：
  前缀检索需求：用户常通过姓名前缀如张→张三、张四或电话前缀如138”→所有 138 开头手机号检索联系人，需实现 O (1)/O (L) 级别的高效检索，L 为前缀长度，而非线性遍历；
  结果限制与提示：检索结果可能过多，需限制最大展示条数如 10 条并提示总匹配数，解决结果刷屏问题；
  去重问题：检索过程中需保证同一联系人不重复展示，解决索引冗余导致结果重复的问题。
  
  #### 二、数据结构层面需解决的问题
  
- 主存储结构的效率问题
  
  - 需选择合适的主存储结构，平衡插入、删除、遍历的效率：采用双向链表作为联系人主表，解决数组插入或删除需移动元素的低效问题；
  - 通过哨兵节点简化双向链表的边界处理，解决空链表、头尾节点操作易出边界异常的问题。
- 索引加速的设计问题
  
  - 需设计轻量化索引结构，解决性能瓶颈。
- 两种索引方案：
  
  - Trie 树索引：解决 “散列表存储大量前缀键导致内存占用高” 的问题。
    
  - 散列表索引：解决 “Trie 树实现复杂、开发成本高” 的问题。
    
    #### 三、持久化层面需解决的问题
    
- 数据持久化的原子性问题
  
  - 解决异常中断导致文件损坏、数据丢失等问题：
    
  - 采用 “临时文件 + 原子重命名” 机制：所有修改先写入临时文件，成功后替换正式文件，避免写入过程中断导致正式文件格式损坏；
    
  - 启动时自动恢复：优先读取正式文件，若不存在则尝试从临时文件恢复，解决 “异常中断后数据无法恢复” 的问题。
    
    ### 2.4 项目意义
    
- 实际应用价值：解决本地化通讯录管理的核心痛点
  
  - 提升检索效率：通过散列表 / Trie 树前缀索引，将传统 “全量遍历检索” 的 O (n) 时间复杂度优化为 O (1)（散列表）/O (L)（L 为前缀长度），在联系人数据量多于100 条时，检索耗时降低 80% 以上，解决了记不全姓名 / 手机号时检索困难的实际问题；
  - 保障数据可靠性：基于“临时文件 + 原子重命名”的持久化机制，避免了文件写入中断导致的数据损坏或丢失，解决了本地文本通讯录易误删、损坏的痛点；
  - 轻量化适配场景：相比功能冗余的图形界面通讯录软件，本项目以命令行形式实现核心功能，无需依赖网络、云端或复杂运行环境，适配个人本地管理、小型团队临时协作等轻量化场景，满足 “快速录入、快速检索、本地存储” 的刚需。
- 技术学习价值：落地核心数据结构的组合应用
  
  - 线性表实践：通过双向链表实现联系人主表的增删改查，直观掌握双向链表哨兵节点设计，O (1) 插入 / 删除等特性，理解顺序存储结构在实际场景中的优势与应用方式；
  - 索引结构对比：同时实现散列表和 Trie 树两种索引方案，可对比两种结构在前缀检索、内存占用、实现复杂度上的差异，深化对哈希表键值映射、Trie 树前缀共享核心思想的理解；
  - 工程化能力培养：涵盖数据持久化原子性、异常处理、命令行交互设计等工程化细节，学习如何将纯数据结构知识转化为可运行、高可用的实际应用，理解理论设计到工程落地的衔接逻辑。

## 三、项目目标与预期成果

### 3.1 项目目标

- 目标1：能实现项目基本的功能如查询、插入、删除等。
- 目标 2：基于高效数据结构实现前缀检索，大幅提升模糊查询效率，满足姓名/电话前缀快速检索需求。
- 目标 3：保证数据持久化的原子性与一致性，异常中断后可恢复数据，避免文件损坏或数据丢失，同时提供友好的命令行交互与异常提示。

### 3.2 预期成果

- [ ] 可运行的程序代码
- [ ] 项目设计文档
- [ ] 测试用例及测试报告
- [ ] 演示PPT/演示视频
- [ ] 其他:____________________________________________________

### 3.3 验收标准

#### 功能模块

| 功能模块 | 具体验收指标 |
| --- | --- |
| 联系人添加 | 1. 输入`ADD 姓名 电话 [备注]`可成功添加联系人，返回 “添加成功” 提示；<br><br>2. 重复手机号添加时自动覆盖旧联系人，旧数据被删除且新数据生效；<br><br>3. 缺少姓名 / 电话参数时，提示 “参数错误”，不执行添加操作；<br><br>4. 添加后自动触发持久化，生成`address_book.dat`文件，内容包含新增联系人信息。 |
| 联系人删除 | 1. 输入`DEL 手机号`可删除对应联系人，返回 “删除成功” 提示；<br><br>2. 手机号不存在时，返回 “删除失败：手机号 XXX 不存在” 提示；<br><br>3. 删除后自动触发持久化，文件中无该联系人数据；<br><br>4. 删除操作同步更新索引，检索已删除手机号 / 姓名前缀无结果。 |
| 持久化 | 1. 输入`SAVE`可手动触发持久化，返回 “持久化成功：写入 X 条记录到 XXX” 提示；<br><br>2. 程序退出（EXIT）时自动触发持久化；<br><br>3. 异常中断后重启程序，可从临时文件（`address_book.dat.tmp`）恢复数据，且正式文件被更新；<br><br>4. 持久化文件格式为 “姓名 |

#### 性能维度

| 性能维度 | 具体验收指标 |
| --- | --- |
| 操作响应时间 | 1. 单条联系人添加 / 删除操作：响应时间≤100ms（本地文件存储场景）；<br><br>2. 前缀检索操作（≤100 条数据）：响应时间≤50ms；<br><br>3. 全量遍历（≤1000 条数据）：响应时间≤200ms；<br><br>4. 持久化操作（≤1000 条数据）：响应时间≤500ms。 |
| 内存占用 | 1. 存储 1000 条联系人数据时，程序内存占用≤50MB；<br><br>2. 索引结构无内存泄漏，连续执行 100 次添加 + 删除操作后，内存占用无持续增长。 |

- 测试要求：
  - 功能性测试如正常指令插入删除运行正常
  - 边界测试如极限数据测试和边界场景测试正常

## 四、小组成员与分工

| 姓名  | 学号  | 主要职责 | 预计工作量占比 |
| --- | --- | --- | --- |
| 徐书泽 | 24030631 | 代码  | 50% |
| 顾雨辰 | 24030612 | 文本  | 50% |

**协作方式**：

- 交流工具：QQ
- 任务管理：QQ聊天任务分配
- 代码管理：GIT库管理

## 五、技术方案

### 5.1 核心数据结构

| 功能需求 | 采用的数据结构 | 时间复杂度（平均） | 选择理由 |
| --- | --- | --- | --- |
| 联系人主表存储（增 / 删） | 双向链表（带哨兵节点） | 插入 / 删除：O (1) | 1. 无需连续内存空间，插入 / 删除仅需修改节点指针，O (1) 时间完成；<br><br>2. 哨兵节点简化头尾操作，避免边界异常；<br><br>3. 遍历效率与数组持平（O (n)），满足全量展示需求；<br><br>4. 适配联系人动态增删的高频场景，无数组扩容 / 缩容的性能损耗。 |
| 姓名 / 电话前缀检索 | 散列表（哈希表）/Trie 树 | 散列表：检索 O (1)、插入 O (n)（n 为前缀数）；<br><br>Trie 树：检索 / 插入 O (L)（L 为前缀长度） | **散列表**：<br><br>1. 前缀直接作为键，检索时 O (1) 命中，适配短前缀高频检索场景；<br><br>2. 复用 Python 内置字典，实现简单、开发成本低；<br><br>3. 限制前缀最大长度，平衡内存占用与检索效率。<br><br>**Trie 树**：<br><br>1. 共享前缀节点，内存占用远低于散列表（无需存储所有前缀）；<br><br>2. 检索 / 插入时间仅与前缀长度相关，长前缀场景下性能更稳定；<br><br>3. 天然适配前缀检索场景，无哈希冲突风险。 |
| 检索结果去重 | 集合，基于哈希表实现 | 去重：O (m)（m 为检索结果数） | . 以手机号为唯一标识去重，O (1) 时间判断是否重复；<br><br>2. 相比列表遍历去重（O (m²)），哈希集合去重效率提升显著；<br><br>3. 保证检索结果无重复联系人，提升用户体验。 |

### 5.2 主要算法

| 核心算法 | 算法描述 | 时间复杂度（平均） | 空间复杂度 | 适用场景 |
| --- | --- | --- | --- | --- |
| 双向链表节点插入 | 定位链表尾部（哨兵节点 prev），修改节点 prev/next 指针完成尾部插入 | O(1) | O(1) | 联系人添加操作 |
| 双向链表节点删除 | 通过手机号映射定位目标节点，修改前后节点指针移除目标节点 | O(1) | O(1) | 联系人删除操作 |
| 散列表前缀检索 | 以输入前缀为键查询哈希表，返回匹配的联系人列表并去重 | O (1)（检索）+ O (m)（去重，m 为结果数） | O(m) | 姓名 / 电话前缀模糊查询 |
| Trie 树前缀检索 | 遍历前缀字符定位 Trie 节点，收集该节点下所有联系人并去重 | O (L)（L 为前缀长度）+ O (m)（去重） | O(m) | 姓名 / 电话前缀模糊查询（Trie 版） |
| 手机号唯一性校验 | 以手机号为键查询哈希表，判断是否已存在对应联系人 | O(1) | O(1) | 联系人添加前的重复校验 |
| 检索结果去重 | 基于手机号哈希值构建集合，过滤重复联系人 | O (m)（m 为检索结果数） | O(m) | 前缀检索后结果去重 |
| 原子化持久化 | 先写入临时文件，再通过原子重命名替换正式文件，保证数据一致性 | O (n)（n 为联系人总数） | O(n) | 所有增删操作后的数据落地 |

### 5.3 实现方案

### 开发语言：Python 3.8+

### 开发环境：

- 操作系统：Windows 11
  
- 运行环境：Python 3.8 及以上版本
  
- 依赖工具：仅使用 Python 内置模块
  
- 开发工具：VS Code
  
  ### 模块设计：
  

1. **联系人实体模块**：定义联系人核心属性（姓名、电话、备注），封装双向链表节点的指针，提供字典格式转换方法，作为所有操作的基础数据载体。
2. **索引模块**：实现前缀索引核心逻辑，散列表版本通过生成关键词所有前缀构建哈希索引，Trie 树版本通过节点层级存储前缀；支持索引的插入、删除、前缀检索操作，为高效查询提供支撑。
3. **通讯录核心管理模块**：整合双向链表主存储、索引模块、手机号映射哈希表，实现联系人的添加、删除、前缀检索、全量遍历核心功能；封装原子化持久化逻辑，保证数据一致性；负责启动时从文件恢复数据，是整个系统的核心调度模块。
4. **命令行交互模块**：提供用户与系统的交互入口，解析用户输入的命令，调用 AddressBook 类的对应方法；包含命令参数校验、异常捕获与提示，保证交互的友好性和程序的稳定性。
5. **持久化模块**：作为 AddressBook 类的内部方法，负责数据的加载；加载时优先读取正式文件，异常时从临时文件恢复；持久化时先写临时文件再原子替换，避免文件损坏，保障数据可靠性。

### 输入输出设计：

- 输入方式：
  - 命令行交互式输入：用户通过终端 / 控制台逐行输入文本命令，支持的命令格式标准化，具体如下：
    - 添加联系人：`ADD <姓名> <电话> [备注]`（姓名、电话为必填项，备注为可选项，参数间以空格分隔）；
    - 删除联系人：`DEL <电话>`（仅需传入待删除联系人的手机号）；
    - 姓名前缀检索：`FIND_NAME <前缀>`（传入姓名前缀，支持任意字符组合）；
    - 电话前缀检索：`FIND_PHONE <前缀>`（传入电话前缀，支持数字字符组合）；
    - 全量遍历：`LIST`
    - 手动持久化：`SAVE`
    - 退出系统：`EXIT`
- 输出方式：
  -命令行文本实时输出：所有操作结果以纯文本形式即时打印在终端 / 控制台，格式清晰、语义明确，具体如下：
  - 操作成功提示：如添加成功返回`添加成功：姓名=张三，电话=13800138000`，删除成功返回`删除成功：姓名=张三，电话=13800138000`；
  - 操作失败提示：如手机号不存在返回`删除失败：手机号 13800138000 不存在`，参数错误返回`参数错误：ADD 需要 姓名、电话，可选备注`；
  - 检索结果输出：匹配到联系人时按序号列出 `1. 姓名：张三，电话：13800138000，备注：同事`，无匹配结果返回`未找到匹配的联系人`，结果超限时提示`提示：匹配结果共 15 条，仅展示前 10 条`；
  - 持久化结果输出：成功时返回`持久化成功：写入 3 条记录到 address_book.dat`，失败时返回`持久化失败：[具体异常原因]`；
  - 系统提示：启动时展示功能说明，输入未知命令返回`未知命令，请重新输入`；
  - - 文件持久化输出：所有联系人数据以`姓名|电话|备注`的格式写入本地文件（默认`address_book.dat`），临时文件（`address_book.dat.tmp`）仅作为原子化写入的中间载体，最终结果落地至正式文件，文件编码为 UTF-8，无冗余空行，便于手动查看 / 编辑。

## 六、进度安排

| 阶段  | 主要任务 | 负责人 | 起止时间 | 输出成果 |
| --- | --- | --- | --- | --- |
| 核心数据结构实现 | 实现双向链表、Trie树、散列表基础操作（徐书泽）；编写数据结构单元测试用例（顾雨辰） | 徐书泽、顾雨辰 | 第1周周二至周三 | 数据结构代码、单元测试脚本与测试报告 |
| 功能模块开发 | 开发ADD/DEL/LIST命令逻辑（徐书泽）；设计命令行交互提示文案，优化用户反馈信息（顾雨辰） | 徐书泽、顾雨辰 | 第1周周六至周日 | 基础功能代码、交互提示规范文档 |
| 索引与检索实现 | 实现Trie树前缀检索与结果去重逻辑（徐书泽）；设计5组检索对比用例（含线性扫描与索引查询对比场景）（顾雨辰） | 徐书泽、顾雨辰 | 第2周周一 | 检索功能代码、对比测试用例文档 |
| 持久化模块开发 | 实现“临时文件+原子重命名”机制与数据恢复逻辑（徐书泽）；编写持久化异常场景测试用例（如断电恢复、文件损坏）（顾雨辰） | 徐书泽、顾雨辰 | 第2周周二 | 持久化代码、异常测试报告 |
| 测试与优化 | 修复功能bug，优化检索性能（徐书泽）；执行全量测试（含功能/性能/边界测试），整理测试结果（顾雨辰） | 徐书泽、顾雨辰 | 第2周周三上午 | 优化后代码、完整测试报告（含性能对比数据） |
| 文档与演示准备 | 整合代码注释，编写用户操作手册（徐书泽）；完善设计文档，制作演示PPT与视频脚本（顾雨辰） | 徐书泽、顾雨辰 | 第2周周三下午 | 用户手册、最终设计文档、PPT、演示视频脚本 |
| 最终整合与验收 | 程序最终编译打包，验证全流程功能（徐书泽）；核对所有交付物完整性，准备提交材料（顾雨辰） | 徐书泽、顾雨辰 | 第2周周四 | 可运行程序包、全套文档（含代码、测试、手册） |

**关键节点**：

- [ ] 第1周周三：核心数据结构及单元测试完成
- [ ] 第1周周日：基础功能代码及交互规范完成
- [ ] 第2周周一：检索功能及对比用例设计完成
- [ ] 第2周周三上午：全量测试及性能优化完成
- [ ] 第2周周四：所有交付物整合提交完成

## 附录：可能遇到的困难及解决思路